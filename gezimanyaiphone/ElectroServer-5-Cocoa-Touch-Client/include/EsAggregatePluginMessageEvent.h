//
//  Autogenerated by CocoaTouchApiGenerator
//
//  DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//



#import <EsMessage.h>
#import <EsMessageType.h>
#import <EsRequest.h>
#import <EsResponse.h>
#import <EsEvent.h>
#import <EsEntity.h>
#import <EsObject.h>
#import <ThriftAggregatePluginMessageEvent.h>
#import <EsFlattenedEsObjectRO.h>
#import <ThriftFlattenedEsObjectRO.h>

/**
 * Most games have a server plugin that contains custom game logic. They usually communicate with clients based on events that occur in the game such as a position update, or a tank firing, 
 or something exploding, etc. In some cases these events could equate to dozens per second. When the message rate starts to get pretty high it is smart to have the client-bound plugin 
 messages aggregated into fewer bigger messages. This can be done easily within a plugin by turning on message queuing, and then using the sendQueuedMessage method instead of the normal 
 method for sending messages. The purge timer can be configured so that message aggregates are sent, say, every 200ms.<br><br>
 
 When the client receives an aggregate, this message event occurs. Most client developers will never need to listen for this event. It is already captured by the ESEngine instance and 
 ripped into its consituent PluginMessageEvent objects. The ESEngine class then fires off individual events for each of those. This means that whether a plugin message is received via 
 PluginMessageEvent or CompositeMessageEvent, the client only needs to listen for PluginMessageEvent.
 */
@interface EsAggregatePluginMessageEvent : EsEvent {
@private
	BOOL pluginName_set_;
	NSString* pluginName_;
	BOOL esObjects_set_;
	NSMutableArray* esObjects_;
	BOOL originZoneId_set_;
	int32_t originZoneId_;
	BOOL originRoomId_set_;
	int32_t originRoomId_;
}

/**
 * Name of the plugin that sent the message(s)
 */
@property(retain,nonatomic) NSString* pluginName;
/**
 * EsObject associated with each plugin message that has been aggregated
 */
@property(retain,nonatomic) NSMutableArray* esObjects;
/**
 * The zone id of the zone that contains the room that contains the plugin that sent this, unless it was a server-level plugin (as opposed to room-level)
 */
@property(nonatomic) int32_t originZoneId;
/**
 * The id of the room that contains the plugin that sent this, unless it was a server-level plugin.
 */
@property(nonatomic) int32_t originRoomId;

- (id) init;
- (id) initWithThriftObject: (id) thriftObject;
- (void) fromThrift: (id) thriftObject;
- (ThriftAggregatePluginMessageEvent*) toThrift;
- (id) newThrift;
@end
